#数据库性能优化

一、使用事务

使用事务的两大好处是原子提交和更优性能。

(1) 原子提交

原则提交意味着同一事务内的所有修改要么都完成要么都不做，如果某个修改失败，会自动回滚使得所有修改不生效。
 
(2) 更优性能

Sqlite默认会为每个插入、更新操作创建一个事务，并且在每次插入、更新后立即提交。

这样如果连续插入100次数据实际是创建事务->执行语句->提交这个过程被重复执行了100次。如果我们显示的创建事务->执行100条语句->提交会使得这个创建事务和提交这个过程只做一次，通过这种一次性事务可以使得性能大幅提升。尤其当数据库位于sd卡时，时间上能节省两个数量级左右。

Sqlte显示使用事务，示例代码如下：
```Java
public void insertWithOneTransaction() {
    SQLiteDatabase db = sqliteOpenHelper.getWritableDatabase();
    // Begins a transaction
    db.beginTransaction();
    try {
        // your sqls
        for (int i = 0; i < 100; i++) {
            db.insert(yourTableName, null, value);
        }
 
        // marks the current transaction as successful
        db.setTransactionSuccessful();
    } catch (Exception e) {
        // process it
        e.printStackTrace();
    } finally {
        // end a transaction
        db.endTransaction();
    }
}
```
二、优化创建SQL语句字符串速度

简单的string相加会导致创建多个临时对象消耗性能，较优的方法是StringBuilder或String.format

三、SQL预编译

execSQL中会编译SQL再执行，相似的SQL语句可以通过compileStatement只编译一次。
```Java
public void populateWithCompileStatement(SQLiteDatabase db) {
	SQLiteStatement stmt = db.compileStatement("insert into cheese values(?,?)");
	for (int i = 0; i < 10; i++) {
		stmt.clearBindings();
		stmt.bindString(1, name);
		stmt.bindString(2, origin);
		stmt.executeInsert();
	}
}
```

三、查询时返回更少的结果集及更少的字段

查询时只取需要的字段和结果集，更多的结果集会消耗更多的时间及内存，更多的字段会导致更多的内存消耗。

四、少用cursor.getColumnIndex

根据性能调优过程中的观察cursor.getColumnIndex的时间消耗跟cursor.getInt相差无几。可以在建表的时候用static变量记住某列的index，直接调用相应index而不是每次查询。


